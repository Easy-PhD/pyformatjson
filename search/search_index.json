{"config":{"lang":["en"],"separator":"[\\s\\u200b\\-_,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"pyformatjson","text":""},{"location":"api-auto/","title":"API Reference","text":"<p>This is the complete API reference documentation for the pyformatjson library.</p>"},{"location":"api-auto/#module-list","title":"Module List","text":""},{"location":"api-auto/#root-modules","title":"Root Modules","text":"<ul> <li>core._base</li> <li>core.update_json</li> <li>main</li> <li>tools.generate_dict</li> <li>tools.write_dict</li> </ul>"},{"location":"api-auto/core._base/","title":"core._base","text":""},{"location":"api-auto/core._base/#pyformatjson.core._base-classes","title":"Classes","text":""},{"location":"api-auto/core._base/#pyformatjson.core._base.IterateSortDict","title":"IterateSortDict","text":"<pre><code>IterateSortDict(reverse=False)\n</code></pre> <p>A class for recursively sorting dictionary keys with natural sorting.</p> <p>This class provides methods to sort dictionary keys recursively, handling nested dictionaries and using natural sorting for strings with embedded numbers.</p> <p>Attributes:</p> Name Type Description <code>reverse</code> <code>bool</code> <p>If True, sorts keys in descending order. Defaults to False.</p> Example <p>sorter = IterateSortDict(reverse=False) data = {\"item10\": {\"sub2\": 1, \"sub1\": 2}, \"item2\": 3} sorted_data = sorter.dict_update(data)</p> <p>Initialize the IterateSortDict instance.</p> <p>Parameters:</p> Name Type Description Default <code>reverse</code> <code>bool</code> <p>If True, sorts keys in descending order. Defaults to False.</p> <code>False</code> Source code in <code>pyformatjson/core/_base.py</code> <pre><code>def __init__(self, reverse: bool = False) -&gt; None:\n    \"\"\"Initialize the IterateSortDict instance.\n\n    Args:\n        reverse (bool, optional): If True, sorts keys in descending order.\n            Defaults to False.\n    \"\"\"\n    self.reverse = reverse\n</code></pre>"},{"location":"api-auto/core._base/#pyformatjson.core._base.IterateSortDict-functions","title":"Functions","text":""},{"location":"api-auto/core._base/#pyformatjson.core._base.IterateSortDict.dict_sort","title":"dict_sort","text":"<pre><code>dict_sort(old)\n</code></pre> <p>Sort dictionary keys using natural sorting.</p> <p>This method sorts the top-level keys of the dictionary using natural sorting that handles embedded numbers.</p> <p>Parameters:</p> Name Type Description Default <code>old</code> <code>dict</code> <p>The dictionary whose keys are to be sorted.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A new dictionary with sorted keys.</p> Source code in <code>pyformatjson/core/_base.py</code> <pre><code>def dict_sort(self, old: dict) -&gt; dict:\n    \"\"\"Sort dictionary keys using natural sorting.\n\n    This method sorts the top-level keys of the dictionary using\n    natural sorting that handles embedded numbers.\n\n    Args:\n        old (dict): The dictionary whose keys are to be sorted.\n\n    Returns:\n        dict: A new dictionary with sorted keys.\n    \"\"\"\n    return {k: old[k] for k in sort_int_str(list(old.keys()), self.reverse)}\n</code></pre>"},{"location":"api-auto/core._base/#pyformatjson.core._base.IterateSortDict.dict_sort_iteration","title":"dict_sort_iteration","text":"<pre><code>dict_sort_iteration(old)\n</code></pre> <p>Recursively sort nested dictionaries.</p> <p>This method iterates through the dictionary and recursively sorts any nested dictionary values.</p> <p>Parameters:</p> Name Type Description Default <code>old</code> <code>dict</code> <p>The dictionary to be processed recursively.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>The dictionary with nested dictionaries sorted.</p> Source code in <code>pyformatjson/core/_base.py</code> <pre><code>def dict_sort_iteration(self, old: dict) -&gt; dict:\n    \"\"\"Recursively sort nested dictionaries.\n\n    This method iterates through the dictionary and recursively sorts\n    any nested dictionary values.\n\n    Args:\n        old (dict): The dictionary to be processed recursively.\n\n    Returns:\n        dict: The dictionary with nested dictionaries sorted.\n    \"\"\"\n    for key in old:\n        if isinstance(old[key], dict):\n            old[key] = self.dict_update(old[key])\n    return old\n</code></pre>"},{"location":"api-auto/core._base/#pyformatjson.core._base.IterateSortDict.dict_update","title":"dict_update","text":"<pre><code>dict_update(old)\n</code></pre> <p>Update and sort a dictionary recursively.</p> <p>This method sorts the dictionary keys and recursively processes any nested dictionaries.</p> <p>Parameters:</p> Name Type Description Default <code>old</code> <code>dict</code> <p>The dictionary to be sorted and updated.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>The updated dictionary with sorted keys at all levels.</p> Source code in <code>pyformatjson/core/_base.py</code> <pre><code>def dict_update(self, old: dict) -&gt; dict:\n    \"\"\"Update and sort a dictionary recursively.\n\n    This method sorts the dictionary keys and recursively processes\n    any nested dictionaries.\n\n    Args:\n        old (dict): The dictionary to be sorted and updated.\n\n    Returns:\n        dict: The updated dictionary with sorted keys at all levels.\n    \"\"\"\n    old = self.dict_sort_iteration(old)\n    old = self.dict_sort(old)\n    return old\n</code></pre>"},{"location":"api-auto/core._base/#pyformatjson.core._base-functions","title":"Functions","text":""},{"location":"api-auto/core._base/#pyformatjson.core._base.sort_int_str","title":"sort_int_str","text":"<pre><code>sort_int_str(str_int, reverse=False)\n</code></pre> <p>Sort list of strings with embedded numbers naturally.</p> <p>This function sorts a list of strings using natural sorting that handles embedded numbers correctly (e.g., \"item2\" comes before \"item10\").</p> <p>Parameters:</p> Name Type Description Default <code>str_int</code> <code>list[str]</code> <p>List of strings to be sorted.</p> required <code>reverse</code> <code>bool</code> <p>If True, sorts in descending order. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: Sorted list of strings.</p> Example <p>sort_int_str([\"item10\", \"item2\", \"item1\"]) ['item1', 'item2', 'item10']</p> Source code in <code>pyformatjson/core/_base.py</code> <pre><code>def sort_int_str(str_int: list[str], reverse: bool = False) -&gt; list[str]:\n    \"\"\"Sort list of strings with embedded numbers naturally.\n\n    This function sorts a list of strings using natural sorting that handles\n    embedded numbers correctly (e.g., \"item2\" comes before \"item10\").\n\n    Args:\n        str_int (list[str]): List of strings to be sorted.\n        reverse (bool, optional): If True, sorts in descending order. Defaults to False.\n\n    Returns:\n        list[str]: Sorted list of strings.\n\n    Example:\n        &gt;&gt;&gt; sort_int_str([\"item10\", \"item2\", \"item1\"])\n        ['item1', 'item2', 'item10']\n    \"\"\"\n    return sorted(str_int, key=sort_strings_with_embedded_numbers, reverse=reverse)\n</code></pre>"},{"location":"api-auto/core._base/#pyformatjson.core._base.sort_strings_with_embedded_numbers","title":"sort_strings_with_embedded_numbers","text":"<pre><code>sort_strings_with_embedded_numbers(s)\n</code></pre> <p>Split string into pieces for natural sorting with embedded numbers.</p> <p>This function splits a string into pieces where numbers are converted to integers for proper natural sorting (e.g., \"item2\" comes before \"item10\").</p> <p>Parameters:</p> Name Type Description Default <code>s</code> <code>str</code> <p>The string to be split into sortable pieces.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: List of string pieces with numbers converted to integers.</p> Example <p>sort_strings_with_embedded_numbers(\"item10\") ['item', 10]</p> Source code in <code>pyformatjson/core/_base.py</code> <pre><code>def sort_strings_with_embedded_numbers(s: str) -&gt; list[str]:\n    \"\"\"Split string into pieces for natural sorting with embedded numbers.\n\n    This function splits a string into pieces where numbers are converted to integers\n    for proper natural sorting (e.g., \"item2\" comes before \"item10\").\n\n    Args:\n        s (str): The string to be split into sortable pieces.\n\n    Returns:\n        list[str]: List of string pieces with numbers converted to integers.\n\n    Example:\n        &gt;&gt;&gt; sort_strings_with_embedded_numbers(\"item10\")\n        ['item', 10]\n    \"\"\"\n    re_digits = re.compile(r\"(\\d+)\")\n    pieces = re_digits.split(s)\n    pieces[1::2] = map(int, pieces[1::2])\n    return pieces\n</code></pre>"},{"location":"api-auto/core._base/#pyformatjson.core._base.split_data_list","title":"split_data_list","text":"<pre><code>split_data_list(split_pattern, data_list, last_next='next')\n</code></pre> <p>Split data list according to the split pattern.</p> <p>This function splits each string in the data list using the provided regex pattern and reconstructs the data based on the last_next parameter. The pattern must use capturing parentheses to define split points.</p> <p>Parameters:</p> Name Type Description Default <code>split_pattern</code> <code>str</code> <p>Regular expression pattern for splitting. Must use capturing parentheses, e.g., r\"(\\n)\" for newline splits.</p> required <code>data_list</code> <code>list[str]</code> <p>List of strings to be split and processed.</p> required <code>last_next</code> <code>str</code> <p>Determines how to handle split parts. \"next\" places the split character at the beginning of the next part, \"last\" places it at the end of the current part. Defaults to \"next\".</p> <code>'next'</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: New list of processed strings with empty strings filtered out.</p> <p>Raises:</p> Type Description <code>error</code> <p>If the split_pattern is not a valid regular expression.</p> Example <p>split_data_list(r\"(\\n)\", [\"line1\\nline2\", \"line3\\nline4\"], \"next\") ['line1', 'line2', 'line3', 'line4']</p> Source code in <code>pyformatjson/core/_base.py</code> <pre><code>def split_data_list(split_pattern: str, data_list: list[str], last_next: str = \"next\") -&gt; list[str]:\n    r\"\"\"Split data list according to the split pattern.\n\n    This function splits each string in the data list using the provided regex pattern\n    and reconstructs the data based on the last_next parameter. The pattern must use\n    capturing parentheses to define split points.\n\n    Args:\n        split_pattern (str): Regular expression pattern for splitting. Must use capturing\n            parentheses, e.g., r\"(\\n)\" for newline splits.\n        data_list (list[str]): List of strings to be split and processed.\n        last_next (str, optional): Determines how to handle split parts. \"next\" places\n            the split character at the beginning of the next part, \"last\" places it at\n            the end of the current part. Defaults to \"next\".\n\n    Returns:\n        list[str]: New list of processed strings with empty strings filtered out.\n\n    Raises:\n        re.error: If the split_pattern is not a valid regular expression.\n\n    Example:\n        &gt;&gt;&gt; split_data_list(r\"(\\n)\", [\"line1\\nline2\", \"line3\\nline4\"], \"next\")\n        ['line1', 'line2', 'line3', 'line4']\n    \"\"\"\n    new_data_list = []\n    for line in data_list:\n        split_list = re.split(split_pattern, line)\n        list_one = split_list[0 : len(split_list) : 2]\n        list_two = split_list[1 : len(split_list) : 2]\n\n        temp = []\n        if last_next == \"next\":\n            list_two.insert(0, \"\")\n            temp = [list_two[i] + list_one[i] for i in range(len(list_one))]\n        if last_next == \"last\":\n            list_two.append(\"\")\n            temp = [list_one[i] + list_two[i] for i in range(len(list_one))]\n        new_data_list.extend(temp)\n    new_data_list = [line for line in new_data_list if line.strip()]\n    return new_data_list\n</code></pre>"},{"location":"api-auto/core._base/#pyformatjson.core._base.split_text_by_length","title":"split_text_by_length","text":"<pre><code>split_text_by_length(text, max_length=120)\n</code></pre> <p>Split text into lines of specified maximum length.</p> <p>This function breaks long text into multiple lines, ensuring each line does not exceed the specified maximum length. It attempts to break at word boundaries when possible.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The input text to be split into lines.</p> required <code>max_length</code> <code>int</code> <p>Maximum length for each line. Defaults to 120.</p> <code>120</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: A list of text lines, each not exceeding max_length characters.</p> Example <p>split_text_by_length(\"This is a very long text that needs to be split\", 20) ['This is a very long', 'text that needs to be', 'split']</p> Source code in <code>pyformatjson/core/_base.py</code> <pre><code>def split_text_by_length(text, max_length=120) -&gt; list[str]:\n    \"\"\"Split text into lines of specified maximum length.\n\n    This function breaks long text into multiple lines, ensuring each line\n    does not exceed the specified maximum length. It attempts to break at\n    word boundaries when possible.\n\n    Args:\n        text (str): The input text to be split into lines.\n        max_length (int, optional): Maximum length for each line. Defaults to 120.\n\n    Returns:\n        list[str]: A list of text lines, each not exceeding max_length characters.\n\n    Example:\n        &gt;&gt;&gt; split_text_by_length(\"This is a very long text that needs to be split\", 20)\n        ['This is a very long', 'text that needs to be', 'split']\n    \"\"\"\n    lines = []\n    while text:\n        if len(text) &lt;= max_length:\n            lines.append(text)\n            break\n\n        split_pos = text.rfind(\" \", 0, max_length + 1)\n        if split_pos == -1:\n            split_pos = max_length\n\n        line = text[:split_pos]\n        lines.append(line)\n\n        text = text[split_pos:]\n\n    new_lines = []\n    for line in lines:\n        new_lines.append(line)\n    return new_lines\n</code></pre>"},{"location":"api-auto/core._base/#pyformatjson.core._base.standardize_path","title":"standardize_path","text":"<pre><code>standardize_path(path_input)\n</code></pre> <p>Standardize and ensure a directory path exists.</p> <p>This function expands environment variables and user home directory references in the path, then creates the directory if it doesn't exist.</p> <p>Parameters:</p> Name Type Description Default <code>path_input</code> <code>str</code> <p>The input path to be standardized and created.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The standardized absolute path.</p> Example <p>standardize_path(\"~/Documents/data\") '/Users/username/Documents/data'</p> Source code in <code>pyformatjson/core/_base.py</code> <pre><code>def standardize_path(path_input: str) -&gt; str:\n    \"\"\"Standardize and ensure a directory path exists.\n\n    This function expands environment variables and user home directory references\n    in the path, then creates the directory if it doesn't exist.\n\n    Args:\n        path_input (str): The input path to be standardized and created.\n\n    Returns:\n        str: The standardized absolute path.\n\n    Example:\n        &gt;&gt;&gt; standardize_path(\"~/Documents/data\")\n        '/Users/username/Documents/data'\n    \"\"\"\n    path_input = os.path.expandvars(os.path.expanduser(path_input))\n    if not os.path.exists(path_input):\n        os.makedirs(path_input)\n    return path_input\n</code></pre>"},{"location":"api-auto/core.update_json/","title":"core.update_json","text":""},{"location":"api-auto/core.update_json/#pyformatjson.core.update_json-classes","title":"Classes","text":""},{"location":"api-auto/core.update_json/#pyformatjson.core.update_json.CheckAcronymAbbrAndFullDict","title":"CheckAcronymAbbrAndFullDict","text":"<pre><code>CheckAcronymAbbrAndFullDict(\n    names_abbr=\"names_abbr\", names_full=\"names_full\"\n)\n</code></pre> Source code in <code>pyformatjson/core/update_json.py</code> <pre><code>def __init__(self, names_abbr=\"names_abbr\", names_full=\"names_full\"):\n    self.names_abbr = names_abbr\n    self.names_full = names_full\n</code></pre>"},{"location":"api-auto/core.update_json/#pyformatjson.core.update_json-functions","title":"Functions","text":""},{"location":"api-auto/core.update_json/#pyformatjson.core.update_json.update_json_file","title":"update_json_file","text":"<pre><code>update_json_file(full_json_cj, conferences_or_journals)\n</code></pre> <p>Update and format JSON file containing conference/journal data.</p> <p>This function loads JSON data, processes and formats text fields by splitting long text into appropriate lengths, checks for duplicate abbreviations, and saves the updated data back to the file.</p> <p>Parameters:</p> Name Type Description Default <code>full_json_cj</code> <code>str</code> <p>Full path to the conferences/journals JSON file</p> required <code>conferences_or_journals</code> <code>str</code> <p>Type of publication ('conferences' or 'journals').</p> required <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>dict[str, Any]: Processed JSON data dictionary.</p> Source code in <code>pyformatjson/core/update_json.py</code> <pre><code>def update_json_file(full_json_cj: str, conferences_or_journals: str) -&gt; dict[str, Any]:\n    \"\"\"Update and format JSON file containing conference/journal data.\n\n    This function loads JSON data, processes and formats text fields by splitting\n    long text into appropriate lengths, checks for duplicate abbreviations, and\n    saves the updated data back to the file.\n\n    Args:\n        full_json_cj (str): Full path to the conferences/journals JSON file\n        conferences_or_journals (str): Type of publication ('conferences' or 'journals').\n\n    Returns:\n        dict[str, Any]: Processed JSON data dictionary.\n    \"\"\"\n    # Load Json Data\n    json_dict = load_json_data(os.path.dirname(full_json_cj), os.path.basename(full_json_cj))\n\n    # Process and format text fields in JSON data.\n    for pub in json_dict:\n        for flag in [\"txt_abouts\", \"txt_remarks\"]:\n            data_list = [p for p in json_dict[pub].get(flag, []) if p.strip()]\n            temps = []\n            for line in split_data_list(r\"(\\n+)\", [\"\".join(data_list)], \"next\"):\n                temps.extend(split_text_by_length(line, 105))\n            if temps:\n                json_dict[pub].update({flag: temps})\n\n        for abbr in json_dict[pub][conferences_or_journals]:\n            for flag in [\"txt_abouts\", \"txt_remarks\"]:\n                data_list = [i for i in json_dict[pub][conferences_or_journals][abbr].get(flag, []) if i.strip()]\n                temps = []\n                for line in split_data_list(r\"(\\n+)\", [\"\".join(data_list)], \"next\"):\n                    temps.extend(split_text_by_length(line, 97))\n                if temps:\n                    json_dict[pub][conferences_or_journals][abbr].update({flag: temps})\n\n    # Generate standard form\n    abbr_dict = generate_standard_form(json_dict, conferences_or_journals)\n\n    _, flag = CheckAcronymAbbrAndFullDict().run(abbr_dict)\n\n    # Save updated JSON\n    if flag and json_dict:\n        with open(full_json_cj, \"w\", encoding=\"utf-8\", newline=\"\\n\") as f:\n            f.write(json.dumps(json_dict, indent=4, sort_keys=True, ensure_ascii=True))\n\n    return json_dict\n</code></pre>"},{"location":"api-auto/main/","title":"main","text":""},{"location":"api-auto/main/#pyformatjson.main-classes","title":"Classes","text":""},{"location":"api-auto/main/#pyformatjson.main-functions","title":"Functions","text":""},{"location":"api-auto/main/#pyformatjson.main.main_generate_md_files","title":"main_generate_md_files","text":"<pre><code>main_generate_md_files(\n    full_json_c,\n    full_json_j,\n    full_json_k,\n    path_output,\n    path_spidered_bibs=None,\n    keywords_category_name=\"\",\n    for_vue=True,\n)\n</code></pre> <p>Generate comprehensive markdown documentation for academic publications.</p> <p>This function serves as the main entry point for processing conference and journal data from JSON files and generating various markdown documentation outputs. It handles both conference and journal data processing, creates categorized outputs, and generates statistics and publisher information files.</p> <p>The function processes three types of JSON files: - Conference data (full_json_c) - Journal data (full_json_j) - Keywords data (full_json_k)</p> <p>Parameters:</p> Name Type Description Default <code>full_json_c</code> <code>str</code> <p>Full path to the conferences JSON file containing conference publication data.</p> required <code>full_json_j</code> <code>str</code> <p>Full path to the journals JSON file containing journal publication data.</p> required <code>full_json_k</code> <code>str</code> <p>Full path to the keywords JSON file containing keyword categorization data.</p> required <code>path_output</code> <code>str</code> <p>Output directory path where all generated markdown files will be saved.</p> required <code>path_spidered_bibs</code> <code>Optional[str]</code> <p>Directory path containing spidered BibTeX files for additional data processing. Defaults to None.</p> <code>None</code> <code>keywords_category_name</code> <code>str</code> <p>Category name for filtering keywords. If provided, only keywords from this category will be processed. Defaults to \"\".</p> <code>''</code> <code>for_vue</code> <code>bool</code> <p>Whether to generate Vue.js-compatible format for date calculations and dynamic content. Defaults to True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>None</code> <code>None</code> <p>This function does not return a value.</p> Source code in <code>pyformatjson/main.py</code> <pre><code>def main_generate_md_files(\n    full_json_c: str,\n    full_json_j: str,\n    full_json_k: str,\n    path_output: str,\n    path_spidered_bibs: str | None = None,\n    keywords_category_name: str = \"\",\n    for_vue: bool = True,\n) -&gt; None:\n    \"\"\"Generate comprehensive markdown documentation for academic publications.\n\n    This function serves as the main entry point for processing conference and journal\n    data from JSON files and generating various markdown documentation outputs. It\n    handles both conference and journal data processing, creates categorized outputs,\n    and generates statistics and publisher information files.\n\n    The function processes three types of JSON files:\n    - Conference data (full_json_c)\n    - Journal data (full_json_j)\n    - Keywords data (full_json_k)\n\n    Args:\n        full_json_c (str): Full path to the conferences JSON file containing\n            conference publication data.\n        full_json_j (str): Full path to the journals JSON file containing\n            journal publication data.\n        full_json_k (str): Full path to the keywords JSON file containing\n            keyword categorization data.\n        path_output (str): Output directory path where all generated markdown\n            files will be saved.\n        path_spidered_bibs (Optional[str], optional): Directory path containing\n            spidered BibTeX files for additional data processing. Defaults to None.\n        keywords_category_name (str, optional): Category name for filtering\n            keywords. If provided, only keywords from this category will be\n            processed. Defaults to \"\".\n        for_vue (bool, optional): Whether to generate Vue.js-compatible format\n            for date calculations and dynamic content. Defaults to True.\n\n    Returns:\n        None: This function does not return a value.\n    \"\"\"\n    # Standardize all paths\n    full_json_c = os.path.expanduser(full_json_c)\n    full_json_j = os.path.expanduser(full_json_j)\n    full_json_k = os.path.expanduser(full_json_k)\n\n    path_output = standardize_path(path_output)\n\n    path_spidered_bibs = standardize_path(path_spidered_bibs) if path_spidered_bibs else \"\"\n\n    # Process keyword category name and load data\n    keywords_category_name = keywords_category_name.lower().strip() if keywords_category_name else \"\"\n    category_prefix = f\"{keywords_category_name}_\" if keywords_category_name else \"\"\n    keywords_json = load_json_data(os.path.dirname(full_json_k), os.path.basename(full_json_k))\n    keywords_list = keywords_json.get(f\"{category_prefix}keywords\", [])\n\n    # Validate data availability\n    if not keywords_list or not keywords_category_name:\n        keywords_list, keywords_category_name = [], \"\"\n\n    # Process both conferences and journals\n    for cj, ia in zip([\"conferences\", \"journals\"], [\"inproceedings\", \"article\"], strict=True):\n        # Update JSON data\n        json_dict = {}\n        if cj == \"conferences\":\n            json_dict = update_json_file(full_json_c, cj)\n        elif cj == \"journals\":\n            json_dict = update_json_file(full_json_j, cj)\n        if not json_dict:\n            continue\n\n        # Generate data dictionaries\n        path_spidered_cj = os.path.join(path_spidered_bibs, cj.title())\n        generater = GenerateDataDict(cj, ia, json_dict, for_vue, path_spidered_cj)\n        publisher_meta_dict, publisher_abbr_meta_dict, keyword_abbr_meta_dict = generater.generate()\n        if not (publisher_meta_dict and publisher_abbr_meta_dict and keyword_abbr_meta_dict):\n            continue\n\n        # Initialize writer and save all markdown files\n        _path_output = os.path.join(path_output, f\"{cj.title()}\")\n        save_data = WriteDataToMd(\n            cj, ia, publisher_meta_dict, publisher_abbr_meta_dict, keyword_abbr_meta_dict, _path_output\n        )\n        # Save various documentation files\n        save_data.save_introductions()\n        save_data.save_categories(keywords_category_name, keywords_list)\n        save_data.save_categories_separate_keywords()\n\n        save_data.save_publishers()\n        save_data.save_publishers_separate_abbrs()\n\n        save_data.save_statistics(keywords_category_name, keywords_list)\n        save_data.save_statistics_separate_abbrs()\n\n    return None\n</code></pre>"},{"location":"api-auto/tools.generate_dict/","title":"tools.generate_dict","text":""},{"location":"api-auto/tools.generate_dict/#pyformatjson.tools.generate_dict-classes","title":"Classes","text":""},{"location":"api-auto/tools.generate_dict/#pyformatjson.tools.generate_dict.GenerateDataDict","title":"GenerateDataDict","text":"<pre><code>GenerateDataDict(\n    conferences_or_journals,\n    inproceedings_or_article,\n    json_dict,\n    for_vue=True,\n    path_spidered_conferences_or_journals=None,\n)\n</code></pre> <p>Generate data dictionaries from JSON input for conferences and journals.</p> <p>This class processes JSON data containing conference or journal information and generates structured dictionaries for markdown table generation, including publisher metadata, keyword-based indexing, and Mermaid diagram data.</p> <p>Attributes:</p> Name Type Description <code>cj</code> <code>str</code> <p>Type of publication ('conferences' or 'journals').</p> <code>ia</code> <code>str</code> <p>Publication type ('inproceedings' or 'article').</p> <code>json_dict</code> <code>dict</code> <p>Input JSON data containing publication information.</p> <code>path_spidered_cj</code> <code>Optional[str]</code> <p>Path to spidered conference/journal data.</p> <code>for_vue</code> <code>bool</code> <p>Whether to generate Vue.js-compatible format.</p> Example <p>generator = GenerateDataDict( ...     conferences_or_journals=\"conferences\", ...     inproceedings_or_article=\"inproceedings\", ...     json_dict=publication_data, ...     for_vue=True ... ) publisher_meta, publisher_abbr, keyword_abbr = generator.generate()</p> <p>Initialize the GenerateDataDict instance.</p> <p>Parameters:</p> Name Type Description Default <code>conferences_or_journals</code> <code>str</code> <p>Type of publication ('conferences' or 'journals').</p> required <code>inproceedings_or_article</code> <code>str</code> <p>Publication type ('inproceedings' or 'article').</p> required <code>json_dict</code> <code>dict</code> <p>Input JSON data containing publication information.</p> required <code>for_vue</code> <code>bool</code> <p>Whether to generate Vue.js-compatible format. Defaults to True.</p> <code>True</code> <code>path_spidered_conferences_or_journals</code> <code>Optional[str]</code> <p>Path to spidered conference/journal data. Defaults to None.</p> <code>None</code> Source code in <code>pyformatjson/tools/generate_dict.py</code> <pre><code>def __init__(\n    self,\n    conferences_or_journals: str,\n    inproceedings_or_article: str,\n    json_dict: dict,\n    for_vue: bool = True,\n    path_spidered_conferences_or_journals: str | None = None,\n) -&gt; None:\n    \"\"\"Initialize the GenerateDataDict instance.\n\n    Args:\n        conferences_or_journals (str): Type of publication ('conferences' or 'journals').\n        inproceedings_or_article (str): Publication type ('inproceedings' or 'article').\n        json_dict (dict): Input JSON data containing publication information.\n        for_vue (bool, optional): Whether to generate Vue.js-compatible format.\n            Defaults to True.\n        path_spidered_conferences_or_journals (Optional[str], optional): Path to\n            spidered conference/journal data. Defaults to None.\n    \"\"\"\n    self.cj = conferences_or_journals\n    self.ia = inproceedings_or_article\n    self.json_dict = json_dict\n\n    self.path_spidered_cj = path_spidered_conferences_or_journals\n    self.for_vue = for_vue\n</code></pre>"},{"location":"api-auto/tools.generate_dict/#pyformatjson.tools.generate_dict.GenerateDataDict-functions","title":"Functions","text":""},{"location":"api-auto/tools.generate_dict/#pyformatjson.tools.generate_dict.GenerateDataDict.conference_or_journal","title":"conference_or_journal","text":"<pre><code>conference_or_journal(publisher_url, abbr, abbr_dict)\n</code></pre> <p>Process conference or journal data and generate formatted information.</p> <p>This method processes individual conference or journal data, validates name lengths, extracts information, formats URLs, and generates table row data for markdown output.</p> <p>Parameters:</p> Name Type Description Default <code>publisher_url</code> <code>str</code> <p>Publisher's URL for markdown linking.</p> required <code>abbr</code> <code>str</code> <p>Abbreviation identifier for the publication.</p> required <code>abbr_dict</code> <code>dict</code> <p>Dictionary containing publication details including names, URLs, dates, scores, and keywords.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple[dict[str, Any], list[str]]</code> <p>A tuple containing: - dict: Contains formatted about text, remarks, and table row data - list: Sorted list of keywords for the publication</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If full and abbreviated names have mismatched lengths.</p> Example <p>result = generator.conference_or_journal( ...     \"https://publisher.com\", \"ICML\", conf_data ... ) abouts, keywords = result</p> Source code in <code>pyformatjson/tools/generate_dict.py</code> <pre><code>def conference_or_journal(self, publisher_url: str, abbr: str, abbr_dict: dict) -&gt; tuple[dict[str, Any], list[str]]:\n    \"\"\"Process conference or journal data and generate formatted information.\n\n    This method processes individual conference or journal data, validates\n    name lengths, extracts information, formats URLs, and generates table\n    row data for markdown output.\n\n    Args:\n        publisher_url (str): Publisher's URL for markdown linking.\n        abbr (str): Abbreviation identifier for the publication.\n        abbr_dict (dict): Dictionary containing publication details including\n            names, URLs, dates, scores, and keywords.\n\n    Returns:\n        tuple: A tuple containing:\n            - dict: Contains formatted about text, remarks, and table row data\n            - list: Sorted list of keywords for the publication\n\n    Raises:\n        ValueError: If full and abbreviated names have mismatched lengths.\n\n    Example:\n        &gt;&gt;&gt; result = generator.conference_or_journal(\n        ...     \"https://publisher.com\", \"ICML\", conf_data\n        ... )\n        &gt;&gt;&gt; abouts, keywords = result\n    \"\"\"\n    # Validate full and abbreviated names match in length\n    self._validate_name_lengths(abbr_dict)\n\n    # Extract basic information\n    full_name, abbr_name = self._extract_full_abbr_names(abbr_dict)\n    url_home = self._extract_homepage_url(abbr_dict)\n    period = self._format_period_with_dblp(abbr_dict)\n\n    # Extract text content\n    abouts = self._extract_text_content(abbr_dict, \"txt_abouts\")\n    remarks = self._extract_text_content(abbr_dict, \"txt_remarks\")\n    url_about = self._extract_first_url(abbr_dict, \"urls_about\")\n\n    # Process keywords with Google search links\n    keywords, keywords_url = self._process_keywords(abbr_dict)\n\n    # Format top score with early access link if available\n    top = self._format_top_score(abbr_dict)\n\n    # Generate appropriate table row based on type\n    row_inf = self._generate_table_row(\n        publisher_url, full_name, abbr_name, url_home, url_about, period, top, keywords_url, abbr, abbr_dict\n    )\n\n    return {\"txt_abouts\": abouts, \"txt_remarks\": remarks, \"row_inf\": row_inf}, keywords\n</code></pre>"},{"location":"api-auto/tools.generate_dict/#pyformatjson.tools.generate_dict.GenerateDataDict.generate","title":"generate","text":"<pre><code>generate()\n</code></pre> <p>Generate publisher metadata and keyword-based publication information.</p> <p>This method processes the JSON data to create three main dictionaries: 1. Publisher metadata with URLs and descriptions 2. Publisher abbreviation metadata with detailed publication info 3. Keyword-based metadata for easy searching and categorization</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple[dict, dict, dict]</code> <p>A tuple containing three dictionaries: - publisher_meta_dict: Publisher metadata including URLs and descriptions - publisher_abbr_meta_dict: Publication details indexed by publisher and abbreviation - keyword_abbr_meta_dict: Publication details indexed by keywords</p> Example <p>generator = GenerateDataDict(...) pub_meta, pub_abbr, keyword_abbr = generator.generate()</p> Source code in <code>pyformatjson/tools/generate_dict.py</code> <pre><code>def generate(self) -&gt; tuple[dict, dict, dict]:\n    \"\"\"Generate publisher metadata and keyword-based publication information.\n\n    This method processes the JSON data to create three main dictionaries:\n    1. Publisher metadata with URLs and descriptions\n    2. Publisher abbreviation metadata with detailed publication info\n    3. Keyword-based metadata for easy searching and categorization\n\n    Returns:\n        tuple: A tuple containing three dictionaries:\n            - publisher_meta_dict: Publisher metadata including URLs and descriptions\n            - publisher_abbr_meta_dict: Publication details indexed by publisher and abbreviation\n            - keyword_abbr_meta_dict: Publication details indexed by keywords\n\n    Example:\n        &gt;&gt;&gt; generator = GenerateDataDict(...)\n        &gt;&gt;&gt; pub_meta, pub_abbr, keyword_abbr = generator.generate()\n    \"\"\"\n    publisher_meta_dict, keyword_abbr_meta_dict, publisher_abbr_meta_dict = {}, {}, {}\n\n    for publisher in self.json_dict:\n        # Extract and clean about texts\n        abouts = [p for p in self.json_dict[publisher].get(\"txt_abouts\", []) if p.strip()]\n\n        # Extract and clean about URLs\n        urls_about = [p.strip() for p in self.json_dict[publisher].get(\"urls_about\", []) if p.strip()]\n\n        # Get full names\n        names_full = self.json_dict[publisher].get(\"names_full\", [])\n\n        # Get homepage URLs\n        urls_homepage = self.json_dict[publisher].get(\"urls_homepage\", [])\n\n        # Extract and clean conference/journal URLs\n        urls_cj = [url.strip() for url in self.json_dict[publisher].get(f\"urls_{self.cj}\", []) if url.strip()]\n\n        # Create publisher URL with markdown formatting if homepage exists\n        publisher_url = f\"[{publisher}]({urls_homepage[0]})\" if urls_homepage else publisher\n\n        # Create full name URL with markdown formatting if available\n        if names_full:\n            full_url = f\"[{names_full[0]}]({urls_homepage[0]})\" if urls_homepage else names_full[0]\n        else:\n            full_url = publisher\n\n        # Extract and clean remarks\n        remarks = [p for p in self.json_dict[publisher].get(\"txt_remarks\", []) if p.strip()]\n\n        # Update publisher metadata\n        publisher_meta_dict.setdefault(publisher, {}).update(\n            {\n                \"full_name_url\": full_url,\n                \"txt_abouts\": abouts,\n                \"txt_remarks\": remarks,\n                \"urls_about\": urls_about,\n                \"url_conferences_or_journals\": f\"[{self.cj.title()}]({urls_cj[0]})\" if urls_cj else \"\",\n            }\n        )\n\n        # Process each abbreviation (conference/journal)\n        for abbr in self.json_dict[publisher][self.cj]:\n            abbr_dict = self.json_dict[publisher][self.cj][abbr]\n\n            # Get conference/journal info and keywords\n            temp_dict, keywords = self.conference_or_journal(publisher_url, abbr, abbr_dict)\n\n            # Generate mermaid diagram data\n            mermaid = self.generate_mermaid_data(publisher, abbr, self.ia)\n\n            publisher_abbr_meta_dict.setdefault(publisher, {}).setdefault(abbr, {}).update(temp_dict)\n            publisher_abbr_meta_dict.setdefault(publisher, {}).setdefault(abbr, {}).update({\"statistics\": mermaid})\n\n            # Index by keywords for quick lookup\n            for keyword in keywords:\n                keyword_abbr_meta_dict.setdefault(keyword, {}).setdefault(abbr, {}).update(temp_dict)\n                keyword_abbr_meta_dict.setdefault(keyword, {}).setdefault(abbr, {}).update({\"statistics\": mermaid})\n\n    return publisher_meta_dict, publisher_abbr_meta_dict, keyword_abbr_meta_dict\n</code></pre>"},{"location":"api-auto/tools.generate_dict/#pyformatjson.tools.generate_dict.GenerateDataDict.generate_mermaid_data","title":"generate_mermaid_data","text":"<pre><code>generate_mermaid_data(\n    publisher, abbr, inproceedings_or_article\n)\n</code></pre> <p>Generate Mermaid diagram data from spidered README files.</p> <p>This method reads spidered data from README files and generates Mermaid chart configuration for visualizing publication statistics.</p> <p>Parameters:</p> Name Type Description Default <code>publisher</code> <code>str</code> <p>Publisher name.</p> required <code>abbr</code> <code>str</code> <p>Publication abbreviation.</p> required <code>inproceedings_or_article</code> <code>str</code> <p>Publication type.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: Mermaid chart configuration lines, or empty list if no data found.</p> Source code in <code>pyformatjson/tools/generate_dict.py</code> <pre><code>def generate_mermaid_data(self, publisher: str, abbr: str, inproceedings_or_article: str) -&gt; list[str]:\n    \"\"\"Generate Mermaid diagram data from spidered README files.\n\n    This method reads spidered data from README files and generates\n    Mermaid chart configuration for visualizing publication statistics.\n\n    Args:\n        publisher (str): Publisher name.\n        abbr (str): Publication abbreviation.\n        inproceedings_or_article (str): Publication type.\n\n    Returns:\n        list[str]: Mermaid chart configuration lines, or empty list if no data found.\n    \"\"\"\n    path_spidered_cj = self.path_spidered_cj if self.path_spidered_cj else \"\"\n    path_readme = os.path.join(path_spidered_cj, publisher, abbr, inproceedings_or_article)\n    full_readme = os.path.expanduser(os.path.join(path_readme, \"README.md\"))\n    if not os.path.exists(full_readme):\n        return []\n\n    mermaid, data_dict = [], {}\n    # |AAAI|1980|95|Proceedings of the First National Conference on Artificial Intelligence|\n    regex = re.compile(r\"\\|.*\\|([0-9]+)\\|([0-9]+)\\|.*\\|\")\n    with open(full_readme, encoding=\"utf-8\", newline=\"\\n\") as file:\n        data_list = file.readlines()\n    for line in data_list:\n        if mch := regex.search(line):\n            data_dict.setdefault(mch.group(1), []).append(mch.group(2))\n    data_dict = {year: sum([int(n) for n in data_dict[year]]) for year in data_dict}\n\n    # Mermaid\n    if len(data_dict) != 0:\n        mermaid = [\"```mermaid\\n\"]\n        mermaid.extend(\n            [\n                \"---\\n\",\n                \"config:\\n\",\n                \"    xyChart:\\n\",\n                \"        width: 1200\\n\",\n                \"        height: 600\\n\",\n                \"    themeVariables:\\n\",\n                \"        xyChart:\\n\",\n                '            titleColor: \"#ff0000\"\\n',\n                \"---\\n\",\n            ]\n        )\n        mermaid.extend([\"xychart-beta\\n\", f'    title \"{abbr}\"\\n'])\n\n        x_axis, bar, line = [], [], []\n        for year in data_dict:\n            x_axis.append(int(year))\n            bar.append(data_dict[year])\n            line.append(data_dict[year])\n\n        idx = next((i for i, year in enumerate(x_axis) if year &gt;= 2000), len(x_axis))\n        x_axis, bar, line = x_axis[idx:], bar[idx:], line[idx:]\n\n        mermaid.append(f\"    x-axis {x_axis}\\n\")\n        mermaid.append('    y-axis \"Number of Papers\"\\n')\n        mermaid.append(f\"    bar {bar}\\n\")\n        mermaid.append(f\"    line {line}\\n\")\n        mermaid.append(\"```\\n\")\n\n    return mermaid\n</code></pre>"},{"location":"api-auto/tools.generate_dict/#pyformatjson.tools.generate_dict-functions","title":"Functions","text":""},{"location":"api-auto/tools.generate_dict/#pyformatjson.tools.generate_dict.conference_journal_header","title":"conference_journal_header","text":"<pre><code>conference_journal_header()\n</code></pre> <p>Generate markdown table headers for conferences and journals.</p> <p>This function creates the appropriate markdown table headers for displaying conference and journal information in tabular format.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple[list[str], list[str]]</code> <p>A tuple containing two lists: - conference_header: Markdown table headers for conferences - journal_header: Markdown table headers for journals</p> Example <p>conf_header, journal_header = conference_journal_header() print(conf_header[0]) |Publishers|Full/Homepage|Abbr/About|Acronym/Archive|Period/DBLP|...</p> Source code in <code>pyformatjson/tools/generate_dict.py</code> <pre><code>def conference_journal_header() -&gt; tuple[list[str], list[str]]:\n    \"\"\"Generate markdown table headers for conferences and journals.\n\n    This function creates the appropriate markdown table headers for displaying\n    conference and journal information in tabular format.\n\n    Returns:\n        tuple: A tuple containing two lists:\n            - conference_header: Markdown table headers for conferences\n            - journal_header: Markdown table headers for journals\n\n    Example:\n        &gt;&gt;&gt; conf_header, journal_header = conference_journal_header()\n        &gt;&gt;&gt; print(conf_header[0])\n        |Publishers|Full/Homepage|Abbr/About|Acronym/Archive|Period/DBLP|...\n    \"\"\"\n    o = \"|Publishers|Full/Homepage|Abbr/About|\"\n    t = \"|-         |-            |-         |\"\n    conference_header = [\n        f\"{o}Acronym/Archive|Period/DBLP|Top|CCF|Submission|Days Left|Main Conf.|Days Left|Location|Keywords/Google|\\n\",\n        f\"{t}-              |-          |-  |-  |-         |-        |          |-        |-       |-              |\\n\",\n    ]\n    journal_header = [\n        f\"{o}Acronym/Issues|Period/DBLP|Top/Early|CCF|CAS|JCR|IF|Keywords/Google|\\n\",\n        f\"{t}-             |-          |-        |-  |-  |-  |- |-              |\\n\",\n    ]\n    return conference_header, journal_header\n</code></pre>"},{"location":"api-auto/tools.write_dict/","title":"tools.write_dict","text":""},{"location":"api-auto/tools.write_dict/#pyformatjson.tools.write_dict-classes","title":"Classes","text":""},{"location":"api-auto/tools.write_dict/#pyformatjson.tools.write_dict.WriteDataToMd","title":"WriteDataToMd","text":"<pre><code>WriteDataToMd(\n    conferences_or_journals,\n    inproceedings_or_article,\n    publisher_meta_dict,\n    publisher_abbr_meta_dict,\n    keyword_abbr_meta_dict,\n    path_output,\n)\n</code></pre> <p>Class to write publication data to Markdown files.</p> <p>This class provides methods to generate various markdown documentation files from processed publication data, including introduction files, categorized listings, publisher information, and statistics.</p> <p>Attributes:</p> Name Type Description <code>cj</code> <code>str</code> <p>Type of publication ('conferences' or 'journals').</p> <code>ia</code> <code>str</code> <p>Publication type ('inproceedings' or 'article').</p> <code>publisher_meta_dict</code> <code>dict</code> <p>Publisher metadata dictionary.</p> <code>publisher_abbr_meta_dict</code> <code>dict</code> <p>Publisher abbreviation metadata dictionary.</p> <code>keyword_abbr_meta_dict</code> <code>dict</code> <p>Keyword-based metadata dictionary.</p> <code>path_output</code> <code>str</code> <p>Output directory path for generated files.</p> Example <p>writer = WriteDataToMd( ...     conferences_or_journals=\"conferences\", ...     inproceedings_or_article=\"inproceedings\", ...     publisher_meta_dict=pub_meta, ...     publisher_abbr_meta_dict=pub_abbr, ...     keyword_abbr_meta_dict=keyword_abbr, ...     path_output=\"/output\" ... ) writer.save_introductions()</p> <p>Initialize with publication data and output path.</p> <p>Parameters:</p> Name Type Description Default <code>conferences_or_journals</code> <code>str</code> <p>Type of publication ('conferences' or 'journals').</p> required <code>inproceedings_or_article</code> <code>str</code> <p>Publication type ('inproceedings' or 'article').</p> required <code>publisher_meta_dict</code> <code>dict</code> <p>Publisher metadata dictionary.</p> required <code>publisher_abbr_meta_dict</code> <code>dict</code> <p>Publisher abbreviation metadata dictionary.</p> required <code>keyword_abbr_meta_dict</code> <code>dict</code> <p>Keyword-based metadata dictionary.</p> required <code>path_output</code> <code>str</code> <p>Output directory path for generated files.</p> required Source code in <code>pyformatjson/tools/write_dict.py</code> <pre><code>def __init__(\n    self,\n    conferences_or_journals: str,\n    inproceedings_or_article: str,\n    publisher_meta_dict: dict,\n    publisher_abbr_meta_dict: dict,\n    keyword_abbr_meta_dict: dict,\n    path_output: str,\n) -&gt; None:\n    \"\"\"Initialize with publication data and output path.\n\n    Args:\n        conferences_or_journals (str): Type of publication ('conferences' or 'journals').\n        inproceedings_or_article (str): Publication type ('inproceedings' or 'article').\n        publisher_meta_dict (dict): Publisher metadata dictionary.\n        publisher_abbr_meta_dict (dict): Publisher abbreviation metadata dictionary.\n        keyword_abbr_meta_dict (dict): Keyword-based metadata dictionary.\n        path_output (str): Output directory path for generated files.\n    \"\"\"\n    self.cj = conferences_or_journals  # \"conferences\" or \"journals\"\n    self.ia = inproceedings_or_article  # \"inproceedings\" or \"article\"\n    self.publisher_meta_dict = publisher_meta_dict\n    self.publisher_abbr_meta_dict = publisher_abbr_meta_dict\n    self.keyword_abbr_meta_dict = keyword_abbr_meta_dict\n    self.path_output = standardize_path(path_output)\n\n    self._default_inf = [\n        \"- The data for TOP, CCF, CAS, JCR, and IF are sourced from [easyScholar](https://www.easyscholar.cc/).\\n\\n\"\n    ]\n</code></pre>"},{"location":"api-auto/tools.write_dict/#pyformatjson.tools.write_dict.WriteDataToMd-functions","title":"Functions","text":""},{"location":"api-auto/tools.write_dict/#pyformatjson.tools.write_dict.WriteDataToMd.save_categories","title":"save_categories","text":"<pre><code>save_categories(keywords_category_name, keywords_list)\n</code></pre> <p>Save publications categorized by keywords.</p> <p>This method generates markdown files organizing publications by their keywords, creating separate sections for each keyword category.</p> <p>Parameters:</p> Name Type Description Default <code>keywords_category_name</code> <code>str</code> <p>The category name for keywords filtering.</p> required <code>keywords_list</code> <code>list[str]</code> <p>List of keywords to include in the output.</p> required <p>Returns:</p> Name Type Description <code>None</code> <code>None</code> <p>This method does not return a value.</p> Note <p>The output file is saved as 'Categories_{type}_{category}.md' in the output directory.</p> Source code in <code>pyformatjson/tools/write_dict.py</code> <pre><code>def save_categories(self, keywords_category_name: str, keywords_list: list[str]) -&gt; None:\n    \"\"\"Save publications categorized by keywords.\n\n    This method generates markdown files organizing publications by their\n    keywords, creating separate sections for each keyword category.\n\n    Args:\n        keywords_category_name (str): The category name for keywords filtering.\n        keywords_list (list[str]): List of keywords to include in the output.\n\n    Returns:\n        None: This method does not return a value.\n\n    Note:\n        The output file is saved as 'Categories_{type}_{category}.md' in the output directory.\n    \"\"\"\n    conference_header, journal_header = conference_journal_header()\n    data_list = [f\"# {self.cj.title()}\\n\\n\"]\n    data_list.extend(self._default_inf)\n\n    # Add publications for each category\n    for keyword in self._default_or_customized_keywords(keywords_category_name, keywords_list):\n        data_list.append(f\"## {keyword}\\n\\n\")\n\n        # Add appropriate header\n        if self.cj == \"conferences\":\n            data_list.extend(conference_header)\n        else:\n            data_list.extend(journal_header)\n\n        # Add all publications in this category\n        for abbr in self.keyword_abbr_meta_dict[keyword]:\n            data_list.append(self.keyword_abbr_meta_dict[keyword][abbr][\"row_inf\"] + \"\\n\")\n        data_list.append(\"\\n\")\n\n    # Write to file\n    category_postfix = f\"_{keywords_category_name.title()}\" if keywords_category_name else \"\"\n    with open(\n        os.path.join(self.path_output, f\"Categories_{self.cj.title()}{category_postfix}.md\"),\n        \"w\",\n        encoding=\"utf-8\",\n        newline=\"\\n\",\n    ) as f:\n        f.writelines(data_list)\n\n    return None\n</code></pre>"},{"location":"api-auto/tools.write_dict/#pyformatjson.tools.write_dict.WriteDataToMd.save_categories_separate_keywords","title":"save_categories_separate_keywords","text":"<pre><code>save_categories_separate_keywords()\n</code></pre> <p>Save publications categorized by keywords in separate files.</p> <p>This method generates individual markdown files for each keyword category, creating separate files for better organization and navigation.</p> <p>Returns:</p> Name Type Description <code>None</code> <code>None</code> <p>This method does not return a value.</p> Note <p>Each keyword gets its own file saved as '{keyword}.md' in the Categories_{type} subdirectory.</p> Source code in <code>pyformatjson/tools/write_dict.py</code> <pre><code>def save_categories_separate_keywords(self) -&gt; None:\n    \"\"\"Save publications categorized by keywords in separate files.\n\n    This method generates individual markdown files for each keyword category,\n    creating separate files for better organization and navigation.\n\n    Returns:\n        None: This method does not return a value.\n\n    Note:\n        Each keyword gets its own file saved as '{keyword}.md' in the\n        Categories_{type} subdirectory.\n    \"\"\"\n    conference_header, journal_header = conference_journal_header()\n\n    # Add publications for each category\n    for keyword in self.keyword_abbr_meta_dict:\n        data_list = [f\"# {keyword}\\n\\n\"]\n        data_list.extend(self._default_inf)\n\n        # Add appropriate header\n        if self.cj == \"conferences\":\n            data_list.extend(conference_header)\n        else:\n            data_list.extend(journal_header)\n\n        # Add all publications in this category\n        for abbr in self.keyword_abbr_meta_dict[keyword]:\n            data_list.append(self.keyword_abbr_meta_dict[keyword][abbr][\"row_inf\"] + \"\\n\")\n        data_list.append(\"\\n\")\n\n        # Write keyword-specific file\n        path_key = standardize_path(os.path.join(self.path_output, f\"Categories_{self.cj.title()}\"))\n        # Create safe filename by replacing invalid characters\n        safe_keyword = create_safe_filename(keyword).replace(\" \", \"_\")\n        with open(os.path.join(path_key, f\"{safe_keyword}.md\"), \"w\", encoding=\"utf-8\", newline=\"\\n\") as f:\n            f.writelines(data_list)\n\n    return None\n</code></pre>"},{"location":"api-auto/tools.write_dict/#pyformatjson.tools.write_dict.WriteDataToMd.save_introductions","title":"save_introductions","text":"<pre><code>save_introductions()\n</code></pre> <p>Save introduction file with all conferences/journals list.</p> <p>This method generates a comprehensive markdown file containing all conferences or journals in a tabular format with appropriate headers and informational content.</p> <p>Returns:</p> Name Type Description <code>None</code> <code>None</code> <p>This method does not return a value.</p> Note <p>The output file is saved as 'Introductions_{type}.md' in the output directory.</p> Source code in <code>pyformatjson/tools/write_dict.py</code> <pre><code>def save_introductions(self) -&gt; None:\n    \"\"\"Save introduction file with all conferences/journals list.\n\n    This method generates a comprehensive markdown file containing all\n    conferences or journals in a tabular format with appropriate headers\n    and informational content.\n\n    Returns:\n        None: This method does not return a value.\n\n    Note:\n        The output file is saved as 'Introductions_{type}.md' in the output directory.\n    \"\"\"\n    conference_header, journal_header = conference_journal_header()\n    conference_inf, journal_inf = conference_journal_informations()\n\n    data_list = [f\"# {self.cj.title()}\\n\\n\"]\n    data_list.extend(self._default_inf)\n\n    # Add appropriate headers based on type\n    if self.cj.lower() == \"conferences\":\n        data_list.extend(conference_inf)\n        data_list.append(\"|  \" + conference_header[0])\n        data_list.append(\"|- \" + conference_header[1])\n    else:\n        data_list.extend(journal_inf)\n        data_list.append(\"|  \" + journal_header[0])\n        data_list.append(\"|- \" + journal_header[1])\n\n    # Add all publications to table\n    idx = 1\n    for publisher in self.publisher_abbr_meta_dict:\n        for abbr in self.publisher_abbr_meta_dict[publisher]:\n            row_info = self.publisher_abbr_meta_dict[publisher][abbr][\"row_inf\"]\n            data_list.append(f\"|{idx}{row_info}\\n\")\n            idx += 1\n\n    # Write to file\n    output_file = os.path.join(self.path_output, f\"Introductions_{self.cj.title()}.md\")\n    with open(output_file, \"w\", encoding=\"utf-8\", newline=\"\\n\") as f:\n        f.writelines(data_list)\n</code></pre>"},{"location":"api-auto/tools.write_dict/#pyformatjson.tools.write_dict.WriteDataToMd.save_publishers","title":"save_publishers","text":"<pre><code>save_publishers()\n</code></pre> <p>Save publisher overview file with basic information.</p> <p>This method generates a markdown file containing an overview of all publishers with their basic information, about pages, and links to detailed publisher-specific files.</p> <p>Returns:</p> Name Type Description <code>None</code> <code>None</code> <p>This method does not return a value.</p> Note <p>The output file is saved as 'Publishers_{type}.md' in the output directory.</p> Source code in <code>pyformatjson/tools/write_dict.py</code> <pre><code>def save_publishers(self) -&gt; None:\n    \"\"\"Save publisher overview file with basic information.\n\n    This method generates a markdown file containing an overview of all\n    publishers with their basic information, about pages, and links to\n    detailed publisher-specific files.\n\n    Returns:\n        None: This method does not return a value.\n\n    Note:\n        The output file is saved as 'Publishers_{type}.md' in the output directory.\n    \"\"\"\n    data_list_pub = [\n        f\"# Introductions of Publishers and {self.cj.title()}\\n\\n\",\n        \"| |Publishers|About US|Conferences/Journals|Separate Links|\\n\",\n        \"|-|-         |-       |-                   |-             |\\n\",\n    ]\n    idx = 1\n\n    # Add each publisher to table\n    for pub in self.publisher_meta_dict:\n        meta = self.publisher_meta_dict[pub]\n\n        full_name_url, about_url, cj_url, local_url = \"\", \"\", \"\", \"\"\n        if x := meta.get(\"full_name_url\", \"\"):\n            full_name_url = x\n        if x := meta.get(\"url_conferences_or_journals\", \"\"):\n            cj_url = x\n        if pub_intr_urls := meta.get(\"urls_about\", []):\n            about_url = f\"[About US]({pub_intr_urls[0]})\"\n\n        local_url = f\"[{pub}](data/{self.cj.title()}/Publishers_{self.cj.title()}/{pub}.md)\"\n\n        # Create table row\n        row = f\"| {idx} | {full_name_url} | {about_url} | {cj_url} | {local_url} |\\n\"\n        data_list_pub.append(row)\n        idx += 1\n\n    # Write to file\n    with open(\n        os.path.join(self.path_output, f\"Publishers_{self.cj.title()}.md\"), \"w\", encoding=\"utf-8\", newline=\"\\n\"\n    ) as f:\n        f.writelines(data_list_pub)\n    return None\n</code></pre>"},{"location":"api-auto/tools.write_dict/#pyformatjson.tools.write_dict.WriteDataToMd.save_publishers_separate_abbrs","title":"save_publishers_separate_abbrs","text":"<pre><code>save_publishers_separate_abbrs()\n</code></pre> <p>Save detailed publisher information in separate files.</p> <p>This method generates individual markdown files for each publisher, containing detailed information about their conferences/journals, including about sections, remarks, and statistics.</p> <p>Returns:</p> Name Type Description <code>None</code> <code>None</code> <p>This method does not return a value.</p> Note <p>Each publisher gets its own file saved as '{publisher}.md' in the Publishers_{type} subdirectory.</p> Source code in <code>pyformatjson/tools/write_dict.py</code> <pre><code>def save_publishers_separate_abbrs(self) -&gt; None:\n    \"\"\"Save detailed publisher information in separate files.\n\n    This method generates individual markdown files for each publisher,\n    containing detailed information about their conferences/journals,\n    including about sections, remarks, and statistics.\n\n    Returns:\n        None: This method does not return a value.\n\n    Note:\n        Each publisher gets its own file saved as '{publisher}.md' in the\n        Publishers_{type} subdirectory.\n    \"\"\"\n    conference_header, journal_header = conference_journal_header()\n    for pub in self.publisher_meta_dict:\n        data_list = [f\"# {pub}\\n\\n\"]\n        data_list.extend(self._default_inf)\n        meta = self.publisher_meta_dict[pub]\n\n        # Add about and remarks sections\n        for flag in [\"txt_remarks\", \"txt_abouts\"]:\n            if temps := meta.get(flag, []):\n                temps[-1] = f\"{temps[-1].rstrip()}\\n\\n\"\n            if temps:\n                data_list.append(f\"## {flag.title()}\\n\\n\")\n                data_list.extend(temps)\n\n        # Add each conference/journal abbreviation\n        if pub not in self.publisher_abbr_meta_dict:\n            continue\n\n        for abbr in self.publisher_abbr_meta_dict[pub]:\n            data_list.append(f\"## {abbr}\\n\\n\")\n\n            # Add appropriate header\n            if self.cj == \"conferences\":\n                data_list.extend(conference_header)\n            else:\n                data_list.extend(journal_header)\n\n            # Add row information\n            row_info = self.publisher_abbr_meta_dict[pub][abbr][\"row_inf\"]\n            data_list.append(f\"{row_info}\\n\\n\")\n\n            # Add remarks and about for this abbreviation\n            for flag in [\"txt_remarks\", \"txt_abouts\"]:\n                if temps := self.publisher_abbr_meta_dict[pub][abbr].get(flag, []):\n                    temps[-1] = f\"{temps[-1].rstrip()}\\n\\n\"\n                if temps:\n                    data_list.append(f\"### {flag.split('_')[-1].title()}\\n\\n\")\n                    data_list.extend(temps)\n\n            # Add statistics if available\n            if statistics := self.publisher_abbr_meta_dict[pub][abbr].get(\"statistics\", []):\n                data_list.extend(statistics)\n                data_list.append(\"\\n\")\n\n        # Write publisher-specific file\n        path_pub = standardize_path(os.path.join(self.path_output, f\"Publishers_{self.cj.title()}\"))\n        with open(os.path.join(path_pub, f\"{pub}.md\"), \"w\", encoding=\"utf-8\", newline=\"\\n\") as f:\n            f.writelines(data_list)\n\n    return None\n</code></pre>"},{"location":"api-auto/tools.write_dict/#pyformatjson.tools.write_dict.WriteDataToMd.save_statistics","title":"save_statistics","text":"<pre><code>save_statistics(keywords_category_name, keywords_list)\n</code></pre> <p>Save statistics overview file for keywords.</p> <p>This method generates a markdown file containing statistics overview for all keywords with links to their detailed pages.</p> <p>Parameters:</p> Name Type Description Default <code>keywords_category_name</code> <code>str</code> <p>The category name for keywords filtering.</p> required <code>keywords_list</code> <code>list[str]</code> <p>List of keywords to include in the output.</p> required <p>Returns:</p> Name Type Description <code>None</code> <code>None</code> <p>This method does not return a value.</p> Note <p>The output file is saved as 'Statistics_{type}_{category}.md' in the output directory.</p> Source code in <code>pyformatjson/tools/write_dict.py</code> <pre><code>def save_statistics(self, keywords_category_name: str, keywords_list: list[str]) -&gt; None:\n    \"\"\"Save statistics overview file for keywords.\n\n    This method generates a markdown file containing statistics overview\n    for all keywords with links to their detailed pages.\n\n    Args:\n        keywords_category_name (str): The category name for keywords filtering.\n        keywords_list (list[str]): List of keywords to include in the output.\n\n    Returns:\n        None: This method does not return a value.\n\n    Note:\n        The output file is saved as 'Statistics_{type}_{category}.md' in the output directory.\n    \"\"\"\n    data_list = [\n        f\"# Statistics of keywords in {self.cj.title()}\\n\\n\",\n        \"| |keywords|Separate Links|\\n\",\n        \"|-|-      |-             |\\n\",\n    ]\n    idx = 1\n\n    # Add publications for each category\n    for keyword in self._default_or_customized_keywords(keywords_category_name, keywords_list):\n        # Create safe filename for URL\n        safe_keyword = create_safe_filename(keyword).replace(\" \", \"_\")\n        ll = os.path.join(\"data\", self.cj.title(), f\"Statistics_{self.cj.title()}\", f\"{safe_keyword}.md\")\n        local_url = f\"[Link]({ll})\"\n\n        # Create table row\n        row = f\"| {idx} | {keyword} | {local_url} |\\n\"\n        data_list.append(row)\n        idx += 1\n\n    # Write to file\n    category_postfix = f\"_{keywords_category_name.title()}\" if keywords_category_name else \"\"\n    with open(\n        os.path.join(self.path_output, f\"Statistics_{self.cj.title()}{category_postfix}.md\"),\n        \"w\",\n        encoding=\"utf-8\",\n        newline=\"\\n\",\n    ) as f:\n        f.writelines(data_list)\n    return None\n</code></pre>"},{"location":"api-auto/tools.write_dict/#pyformatjson.tools.write_dict.WriteDataToMd.save_statistics_separate_abbrs","title":"save_statistics_separate_abbrs","text":"<pre><code>save_statistics_separate_abbrs()\n</code></pre> <p>Save detailed statistics for each keyword in separate files.</p> <p>This method generates individual markdown files for each keyword, containing detailed statistics and publication information.</p> <p>Returns:</p> Name Type Description <code>None</code> <code>None</code> <p>This method does not return a value.</p> Note <p>Each keyword gets its own file saved as '{keyword}.md' in the Statistics_{type} subdirectory.</p> Source code in <code>pyformatjson/tools/write_dict.py</code> <pre><code>def save_statistics_separate_abbrs(self) -&gt; None:\n    \"\"\"Save detailed statistics for each keyword in separate files.\n\n    This method generates individual markdown files for each keyword,\n    containing detailed statistics and publication information.\n\n    Returns:\n        None: This method does not return a value.\n\n    Note:\n        Each keyword gets its own file saved as '{keyword}.md' in the\n        Statistics_{type} subdirectory.\n    \"\"\"\n    conference_header, journal_header = conference_journal_header()\n\n    # Add publications for each category\n    for keyword in self.keyword_abbr_meta_dict:\n        data_list = [f\"# {keyword}\\n\\n\"]\n\n        for abbr in self.keyword_abbr_meta_dict[keyword]:\n            data_list.append(f\"## {abbr}\\n\\n\")\n\n            # Add appropriate header\n            if self.cj == \"conferences\":\n                data_list.extend(conference_header)\n            else:\n                data_list.extend(journal_header)\n\n            # Add row information\n            row_info = self.keyword_abbr_meta_dict[keyword][abbr][\"row_inf\"]\n            data_list.append(f\"{row_info}\\n\\n\")\n\n            # Add statistics if available\n            if statistics := self.keyword_abbr_meta_dict[keyword][abbr].get(\"statistics\", []):\n                data_list.extend(statistics)\n                data_list.append(\"\\n\")\n\n        # Write publisher-specific file\n        path_pub = standardize_path(os.path.join(self.path_output, f\"Statistics_{self.cj.title()}\"))\n        # Create safe filename by replacing invalid characters\n        safe_keyword = create_safe_filename(keyword).replace(\" \", \"_\")\n        with open(os.path.join(path_pub, f\"{safe_keyword}.md\"), \"w\", encoding=\"utf-8\", newline=\"\\n\") as f:\n            f.writelines(data_list)\n\n    return None\n</code></pre>"},{"location":"api-auto/tools.write_dict/#pyformatjson.tools.write_dict-functions","title":"Functions","text":""},{"location":"api-auto/tools.write_dict/#pyformatjson.tools.write_dict.conference_journal_informations","title":"conference_journal_informations","text":"<pre><code>conference_journal_informations()\n</code></pre> <p>Generate informational content for conferences and journals.</p> <p>This function provides additional informational content that can be included in markdown documentation for conferences and journals.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple[list[str], list[str]]</code> <p>A tuple containing two lists: - conference_inf: List of informational strings for conferences - journal_inf: List of informational strings for journals</p> Example <p>conf_info, journal_info = conference_journal_informations() print(conf_info[0]) !&gt; List of Upcoming International Conferences</p> Source code in <code>pyformatjson/tools/write_dict.py</code> <pre><code>def conference_journal_informations() -&gt; tuple[list[str], list[str]]:\n    \"\"\"Generate informational content for conferences and journals.\n\n    This function provides additional informational content that can be\n    included in markdown documentation for conferences and journals.\n\n    Returns:\n        tuple: A tuple containing two lists:\n            - conference_inf: List of informational strings for conferences\n            - journal_inf: List of informational strings for journals\n\n    Example:\n        &gt;&gt;&gt; conf_info, journal_info = conference_journal_informations()\n        &gt;&gt;&gt; print(conf_info[0])\n        !&gt; [List of Upcoming International Conferences](...)\n    \"\"\"\n    conference_inf = [\n        \"!&gt; [List of Upcoming International Conferences](https://internationalconferencealerts.com/all-events.php)\\n\\n\",\n        \"!&gt; [Conferences in Theoretical Computer Science](https://www.lix.polytechnique.fr/~hermann/conf.php)\\n\\n\",\n    ]\n    journal_inf = []\n    return conference_inf, journal_inf\n</code></pre>"},{"location":"api-auto/tools.write_dict/#pyformatjson.tools.write_dict.create_safe_filename","title":"create_safe_filename","text":"<pre><code>create_safe_filename(text)\n</code></pre> <p>Create a safe filename across all platforms.</p> Source code in <code>pyformatjson/tools/write_dict.py</code> <pre><code>def create_safe_filename(text: str) -&gt; str:\n    \"\"\"Create a safe filename across all platforms.\"\"\"\n    # Remove or replace invalid characters\n    safe_text = re.sub(r'[&lt;&gt;:\"/\\\\|?*]', \"_\", text)\n    # Remove leading/trailing spaces and dots\n    safe_text = safe_text.strip(\" .\")\n    # Ensure it's not empty\n    return safe_text if safe_text else \"unnamed\"\n</code></pre>"},{"location":"api-manual/","title":"API Reference","text":""},{"location":"users-guide/bug-report/","title":"Bug Report","text":""},{"location":"users-guide/installation/","title":"Installation","text":"<ul> <li>uv</li> </ul> <pre><code>uv add pyformatjson\n</code></pre> <ul> <li>pip</li> </ul> <pre><code>pip install pyformatjson\n</code></pre>"},{"location":"users-guide/pull-request/","title":"Pull Request","text":""}]}